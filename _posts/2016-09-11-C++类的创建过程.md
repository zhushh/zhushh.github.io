---
layout: post
title: "C++的建立方式、new和operator new方法"
description: "深入理解C++类的创建过程，了解new操作和operator new方法"
og_image: "documentation/sample-image.jpg"
tags: [C++, new, operator new]
---

类的建立方式
----
### 静态建立

静态建立一个对象是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象；使用这种方法，直接调用类的构造函数。例如下面例子：
```c++
class A {
public:
    A() {...}
};

A a;
```

### 动态建立

动态建立类的对象，是使用new运算符将对象建立在堆空间中，这个过程分两步，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间；这种方法，间接调用类的构造函数。
```c++
class A {
public:
    A() {...}
};

A *ptr = new A();
```

### 建立只能在栈上面创建的类

只有使用new运算符的对象才会建立在堆上面，因此，只需要禁用new运算符就可以实现类对象只能建立在栈上。将operator new()设置为私有方法即可。
```c++
class A {
public:
    A() {...}
    ~A() {...}
private:
    void* operator new(size_t t) {}     // 注意函数的第一个参数和返回值都是固定
    void operator delete(void *p) {}    // 重载new就需要重载delete
};
```

### 建立只能在堆上面创建的类

当对象建立在栈上面时，是由编译器分配内存空间的，调用构造函数来构造栈对象。当对象使用完后，编译器会调用析构函数来释放栈对象所占的空间。编译器管理了对象的整个生命周期。如果编译器无法调用类的析构函数，情况会是怎样的呢？比如，类的析构函数是私有的，编译器无法调用析构函数来释放内存。所以，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。这就可以实现对象只能动态创建。
```c++
class A {
public:
    A() {...}
    void destroy() { delete this; } // 使用完类后必须调用这个方法释放资源
private:
    ~A() {...}
};

// 下面是个继承版本
class A {
public:
    static A* create() { return new A(); }
    void destroy() { delete this; }
protected:
    A() {...}
    virtual ~A() {...}
};
```
