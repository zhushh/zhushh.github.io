---
layout: post
title: "深入理解C++的虚类和虚函数实现方式"
description: "理解虚函数实现原理，理解虚类、基类指针以及一些使用注意"
og_image: "documentation/sample-image.jpg"
tags: [C++, virtual, 虚函数, 虚基类]
---


### 什么是虚函数？

虚函数又称虚方法（因为虚函数只能在类中声明），通过关键字virtual来声明的函数；例如：
```c++
class A {
    virtual void print();   // virtual function
    void print(int);        // non-virtual function
};
```
虚函数存放在虚函数表vtbl中，基类中声明为虚函数的成员方法，在派生类中也仍为虚函数（无论在派生类中有没
有virtual关键字修饰）；


### 认识重载(overloading)、重定义(overriding)和隐藏

重载(overloading)：同一个类中，函数名相同，但参数列表不同

重定义(overriding)：父子类中，函数名相同，参数列表相同，且有virtual修饰

隐藏：父子类中，函数名相同，参数列表相同，但没有virtual修饰；或函数名相同，参数列表不同，无论有无virtual修饰；


### 虚函数是怎么实现的？

#### 基类的虚函数表创建

首先是在基类声明中找到所有的虚函数，按照其声明顺序编码0,1,2...,然后按照此声明顺序为基类创建一个虚函数表，
其内容就是存放指向这些虚函数的函数指针，按照函数的声明顺序将虚函数的地址填入虚函数表中；

#### 派生类的虚函数表创建

首先将基类的虚函数表复制到派生类的虚函数表中；若在派生类中重写了基类的虚函数show，则将派生类的虚函数表中
存放show的函数地址（未重写前存放的是基类的show虚函数的函数地址）更新为重写后函数的函数指针；若派生类增加
了一些虚函数的声明，则将虚函数的地址加到该类函数虚函数表的后面；


### 为什么析构函数最好声明为virtual？

[When to use virtual destructors?](http://stackoverflow.com/questions/461203/when-to-use-virtual-destructors)

如果通过基类指针删除一个派生类的实例的时候，虚的析构函数就非常有用，比如下面：
```c++
class Base {
    // some virtual method
};

class Derived : public Base {
    ~Derived() {
        // do some important cleanup
    }
};
```
这里的基类没有声明为虚方法，假设你再有下面代码：
```c++
Base *b = new Derived();
// use b
delete b;   // Here's the problem
```
因为基类Base的析构函数不是虚方法，而b却又指向Derived的实例，所以delete基类指针b是一个未定义的行为；
这会容易导致Derived的动态分配的内存没有被释放，形成内存泄露。如果基类Base的析构函数是虚方法，那么删除
Base的指针b时，会动态调用指针所指向的实例的析构函数，也就是Derived的析构函数，就不会有内存泄漏。


### 为什么构造函数不可以声明为虚的（virtual）？

先了解一下函数方法的执行顺序，假设pBase为基类Base指针，那么调用`pBase->show()；`的顺序如下：
```
1.判断Base类中show方法是否为虚函数;
2.若show方法不是虚函数，那么找到pBase所指向的对象的所属类Base，执行Base::show();
3.若show方法是虚函数，访问pBase所指向的虚函数表指针得到pBase所指向的对象所在类的虚函数表；
4.查找Base中show()在声明的位序x，到步骤3中得到的虚函数表中找到位序x，从而得到要执行的show函数地址；
5.根据函数地址和Base中声明的show的函数类型（形参和返回值）访问地址所指向的函数；
```
如果构造函数声明为虚方法，那么在调用这个构造函数时无法找到对象所在的类（第3步）的虚函数表；
因此，构造函数不能为虚函数；


### 虚类的构造函数和析构函数的执行顺序是怎样？

举个例子：
```c++
#include <iostream>
using namespace std;

class Test {
public:
    Test() {cout << "Test Constructed" << endl;}
    ~Test() {cout << "Test Destructed" << endl;}
};
class Base {
public:
    Base() {cout << "Base Constructed" << endl;}
    virtual ~Base() {cout << "Base Destructed" << endl;}
};
class Derived: public Base
{
public:
    Derived() {cout << "Derived Constructed" << endl;}
    virtual ~Derived() {cout << "Derived Destructed" << endl;}
private:
    Test t;
};

int main(int argc, char const *argv[])
{
    Base *bptr = new Derived();
    delete bptr;
    return 0;
}
```

上面程序输出结果：
```
Base Constructed
Test Constructed
Derived Constructed
Derived Destructed
Test Destructed
Base Destructed
```

原因分析：

指向派生类的基类指针构造函数和析构函数的执行顺序如下：

基类构造函数->成员变量的构造函数->自身构造函数

自身析构函数->成员变量析构函数->基类析构函数


### 虚函数表是否可以修改？

虚函数表可以修改，看下面例子：
```c++
#include <iostream>
using namespace std;

class animal
{
protected:
    int age;
public:
    virtual void print_age(void) = 0;
};

class dog : public animal
{
public:
    dog() {this -> age = 2;}
    ~dog() { }
    virtual void print_age(void)
    {
        cout<<"Wang, my age = "<<this -> age<<endl;
    }
};

class cat: public animal
{
public:
    cat() {this -> age = 1;};
    ~cat() { }
    virtual void print_age(void)
    {
        cout<<"Miao, my age = "<<this -> age<<endl;
    }
};

int main(void)
{
    cat kitty;
    dog jd;
    animal * pa;
    int * p = (int *)(&kitty);
    int * q = (int *)(&jd);
    p[0] = q[0];
    pa = &kitty;
    pa -> print_age();
    return 0;
}
```
输出结果：
Wang, my age = 1

原因分析要理解虚函数表以及类的存储结构：
```
int * p = (int *)(&kitty)   // p指向kitty
int * q = (int *)(&jd)      // q指向jd
p[0] = q[0]   // 把kitty的指向cat::print_age的指针值，修改成指向了dog::print_age
pa = &kitty   // pa指向kitty
pa->print_age()  // 调用的是刚刚被修改过的函数指针，也就是dog::print_age函数，但是
// 在this->age的这个语句的this是kitty,age也就自然是kitty的1
```

### 参考链接

[http://blog.csdn.net/generalharry/article/details/11866997](http://blog.csdn.net/generalharry/article/details/11866997)
